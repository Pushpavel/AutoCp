package config

import com.intellij.openapi.options.SettingsEditor
import com.intellij.openapi.project.DumbAware
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.DialogPanel
import com.intellij.openapi.ui.ValidationInfo
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.ui.CollectionComboBoxModel
import com.intellij.ui.layout.ValidationInfoBuilder
import com.intellij.ui.layout.panel
import database.autoCp
import settings.langSettings.AutoCpLangSettings
import settings.langSettings.model.BuildConfig
import ui.dsl.comboBoxView
import ui.dsl.startValidating
import ui.helpers.isError
import kotlin.io.path.Path

/**
 * UI Editor of [AutoCpConfig] Run Configuration
 */
class ConfigEditor(project: Project) : SettingsEditor<AutoCpConfig>(), DumbAware {
    var solutionFilePath = ""
    private var buildConfigId: Long? = null

    private val buildConfigsModel = CollectionComboBoxModel<BuildConfig>()

    private lateinit var editor: DialogPanel
    private val db = project.autoCp()

    override fun createEditor() = panel {
        row("Solution File:") {
            textFieldWithBrowseButton(::solutionFilePath, "Select Solution File")
                .withValidationOnInput {
                    validateSolutionFilePath(it.text).also { info ->
                        if (info.isError())
                            buildConfigsModel.removeAll()
                    }
                }
        }
        row("Build Configuration:") {
            comboBoxView(
                buildConfigsModel,
                { it.id == buildConfigId },
                { buildConfigId = it?.id },
                BuildConfig.cellRenderer()
            )
        }
    }.also {
        editor = it
        it.startValidating(this)
    }


    private fun ValidationInfoBuilder.validateSolutionFilePath(pathString: String): ValidationInfo? {

        if (pathString.isBlank())
            return error("Must not be empty")

        val file: VirtualFile?

        try {
            file = LocalFileSystem.getInstance().findFileByNioFile(Path(pathString))
        } catch (e: Exception) {
            return error("Invalid path")
        }

        if (file?.exists() != true)
            return error("File does not exists")

        val lang = AutoCpLangSettings.findLangByFile(file)
            ?: return warning("File's language is not registered in Settings/Preferences > Tools > AutoCp > Languages")

        buildConfigsModel.replaceAll(lang.buildConfigs)

        if (!db.solutionFiles.containsKey(pathString))
            return warning("File is not associated with any Competitive programming problem, only files generated by AutoCp after gathering using Tools > Gather Problems can be used")

        return null
    }

    /**
     * Settings to UI
     */
    override fun resetEditorFrom(s: AutoCpConfig) {
        solutionFilePath = s.solutionFilePath
        buildConfigId = s.buildConfigId
        editor.reset()
    }

    /**
     * UI to Settings
     */
    override fun applyEditorTo(s: AutoCpConfig) {
        editor.apply()

        s.solutionFilePath = solutionFilePath
        s.buildConfigId = buildConfigId
    }

}